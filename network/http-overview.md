### Reference

[HTTP 완벽가이드](http://m.yes24.com/goods/detail/15381085)  
[모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-웹-네트워크/dashboard)
___
## 시작하며

감사하게도 제가 근무하는 회사에서 HTTP에 대해 발표를 하게 될 기회를 갖게되어  
좀 더 제대로 HTTP에 개한 개념을 정리하고자 이 글을 연재하게 되었습니다.  
이 글은 대부분 [HTTP 완벽가이드](http://m.yes24.com/goods/detail/15381085) 라는 책을 바탕으로 정리된 글이며,  
해당 서적의 챕터별로 포스팅이 나눠져서 업로드 됩니다.  
기타 참고할만한 강의나 자료는 포스팅의 최상단에 있는 항목인 Reference 항목에 있는 자료들을 추가했습니다.   
이 글을 작성하는 저 뿐만 아니라 읽으시는 모두에게 쉬운 이해를 위해 다소 [비유의 함정](https://m.blog.naver.com/mal2010/120135875306) 이 있을 수 있습니다.  
비개발자 분들도 읽을 수 있게 글을 쓰는것을 지향합니다.  
모든 지적과 질문을 댓글을 통해 감사히 받겠습니다. 보시는 모두가 도움이 되기를 바라며 글을 시작하겠습니다.

# HTTP 개관

지금 시대는 모든 것을 HTTP로 전송한다. HTML, 이미지, 영상, 파일뿐만 아니라  
앱과 서버가 통신할 때, 또 서버와 서버가 통신할 때도 대부분 HTTP를 사용한다.  
즉 웹으로 통신하는 거의 **모든것들이 HTTP기반**이다.  
이번 포스팅에선 이 HTTP가 뭔지, HTTP는 어떤 방식으로 소통을 하는지,  
그리고 HTTP에서 주로 사용되는 개념은 어떤게 있는지 **개괄적으로** 알아보자.  

## HTTP: 인터넷의 멀티미디어 배달부

<img width="50%" src="https://drive.google.com/uc?id=1G9j_aq70QChzYd2NuMCPszC530284y4V">  

HTTP는 **H**yper**T**ext **T**ransfer **P**rotocol의 약자이다.  
웹에서 클라이언트와 서버 사이에 이루어지는 요청과 응답의 **양식과 규칙의 체계**이다.  
우체국을 통해 편지를 보낸다고 가정을 해보자.  
편지를 붙이기 위해 편지 봉투가 필요할 것이며, 편지가 도착할 주소가 필요하고, 그리고 편지의 내용이 필요할 것이다.  
봉투와 우표 그리고 편지를 받는 주소가 필요하며 우체통이나 우체국을 통해 보내는것 처럼  
웹에서도 통신을 위해 양식과 규칙의 체계가 정해져 있는데, 이러한 체계가 바로 HTTP이다.   
지금 이 글을 보고 잇는 동안에도, 본문의 내용뿐만 아니라 블로그를 구성하고있는 뼈대 또한  
HTTP를 통해 당신의 브라우저에 도착했을것이며, 수 많은 이미지, HTML페이지,  
텍스트파일, 동영상, 음성파일 등이 인터넷을 항해 중 이다.  
이 HTTP는 데이터가 지구 반대편에서 오더라도 **정보가 손상되거나 순서가 섞이지 않음**을 보장한다.  
어떤 원리로 이러한것들을 보장하는지는 다른 추후 자세히 다루도록 하겠다.  

## 웹 클라이언트와 서버

웹 컨텐츠는 웹 **서버**에 존재한다. 웹 서버는 **HTTP**로 의사소통하기 때문에  
보통 **HTTP 서버**라고 불린다. 이 서버는 인터넷의 **데이터를 저장**하고,  
HTTP 클라이언트가 **요청한 데이터를 제공**한다.  

<img width="50%" src="https://drive.google.com/uc?id=1L4KkhgX4PTwtqse7QUeOJ5T6QLjSyUlq">   

위 그림과 같이 클라이언트는 필요한 데이터가 있을 때 서버에게 **요청**을 하고,  
서버는 요청받은 내용에 따라 필요한 데이터를 실어서 **응답**을 준다.  
물론 해당하는 데이터를 찾지 못하거나 요청이 올바르지 않다면 그에 따라 응답을 준다.  

## 리소스

리소스는 웹 컨텐츠를 이루는 **자원**이다. 이미지, 동영상, 텍스트파일 등 모든게 리소스에 해당한다.  
웹 클라이언트와 서버 목차에 사용된 그림에서, index.html문서를 원한다고 클라이언트가 요청을 하고있다.  
요청받아서 응답과 함께 주는 html파일 또한 리소스에 해당한다.  
우리가 사용하는 웹앱의 화면들은 서버에서 **응답받은 리소스**들로 구성되어 있다.  

## 미디어 타입

인터넷은 수많은 종류의 데이터 타입(jpg, txt, wmv등)을 가진 리소스를 다룬다.  
이것들을 구분하기 위해서 HTTP는 **MIME(Multipurpose Internet Mail Extensions)타입** 이라는  
데이터 포맷을 가진다. 이것은 원래 **각기 다른 전자메일 시스템 사이**에서 메세지가 오갈 때 겪는 문제점을 해결하기  
위해 설계 되었지만, 이메일에서도 워낙 잘 작동했기 때문에 HTTP에서도 이러한 방식을 채택하여 컨텐츠를 구분한다.  

<img width="50%" src="https://drive.google.com/uc?id=1PG0lrX0rv3aIDZ4Ww3LKyG277KEft2lH">

유튜브에서 동영상을 불러올 때 http메세지를 가져왔다.  
위 메세지와 같이 어떤 데이터타입인지 라벨을 붙여주고, 응답을 받은 브라우저는 다룰 수 있는 데이터인지 확인한다.  

- HTML로 작성된 텍스트 문서는 text/html 라벨이 붙는다.
- plain ASCII 텍스트 문서는 text/plain 라벨이 붙는다.
- JPEG 이미지는 image/jpeg가 붙는다.
- JSON은 application/json이 붙는다.

이 외에도 수 많은 MIME타입이 있다.  
[MDN-MIME타입](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types)

## URI (Uniform Resource Identifier)

서버에 있는 리소스는 각자 이름을 가지고있다.  
클라이언트는 필요한 리소스를 **지목**해서 요청을 해야하는데, 지목할 리소스는 각자 식별할 수 있는 주소나 이름이 있어야 한다.  
예를 들어 아이폰12를 택배로 주문을 시켰는데 아이패드가 택배로 오면 안되기 때문이다.(ㄱㅇㄷ)  

리소스를 **구분**하는 방법에는 아래 그림과 같이 크게 두가지로 분류된다.  
<img width="50%" src="https://drive.google.com/uc?id=1zPs--NgoeeFI-PJyIJIB13R6-j7HlcYx">  

### URL (Uniform Resource Locator)

가장 널리쓰이고 흔한 행태이며 서버의 한 리소스에 대한 구체적인 **위치**를 서술한다.  
URL은 리소스가 정확히 어디에 있고 어떻게 접근할 수 있는지 구체적으로 알려준다.  
오늘날 대부분의 URI는 URL이다.

<img width="80%" src="https://drive.google.com/uc?id=154Qx6MG3ckgvuY_5-Y2JfmPe3S9q3iT4">

**네이버**에서 **webtoon**에 위치해 있는 **titleId가 602910**을 가진 리소스이다.  
titleId만 살짝 바꾸면, 다른 웹툰을 가져오거나 유효하지 않은 웹툰이라고 할것이다.  
위와 같이 어떻게 리소스의 정확한 위치와 접근방법을 표현하는지 상용되는 URL을 보면 알 수 있다.

### URN (Uniform Resource Name)

또다른 구분 방식인 URN은 리소스의 **위치에 영향을 받지 않는 고유한 이름**이다.  
이러한 독립적인 URN은 리소스를 다른 위치로 옮기더라도 문제없이 찾아낼 수 있다.  

<img width="50%" src="https://drive.google.com/uc?id=1Ntkpl9xN8BB2C_CQNOVHP-7tdjv0qJDC">  

위 그림과 같이 URN또한 고유한 체계가 있다. 하지만 URN은 여전히 실험 중인 상태고,  
아직 널리 채택되지 않았다. 그래서 통상적인 관래로 URI와 URL을 같은 의미로 주로 사용중이다.  

## 트랜잭션

<img width="50%" src="https://drive.google.com/uc?id=1vRggrvOquLilTo0eKkFoxXSK39sMv0ZT">  

보통 트랜잭션이라고 하면 데이터베이스에서의 트랜잭션을 떠올리는데,  
트랜잭션의 사전적 의미는 일련된 작업이라는 뜻이다.  
HTTP에는 클라이언트가 서버에서 보내는 **요청 명령**과 서버에서 클라이언트에게 응답해주는 **응답 결과**  
가 있는데, HTTP트랜잭션은 이러한 **하나의 특정 요청과 그 요청에 해당하는 하나의 응답메세지의 묶음**을 의미한다.  

## 메서드

클라이언트는 단지 리소스를 불러오기만 하지는 않을것이다.  
지금 이 글의 작성을 마치고 등록을 누르면 이 글에 해당하는 리소스들을 서버에 **등록**을 해야 할 것이고,  
서버는 내가 올린 글을 저장을 할것이다.  
그렇기에 단순히 리소스를 불러오는것과, 등록을 하는 **행위는 구분**되어져야 한다.  
HTTP는 이러한 행위를 **메서드**를 통해 구분하고 있다.  

|HTTP 메서드|설명|
|---|---|
|GET|서버에서 클라이언트로 지정한 리소스를 보내라|
|PUT|지정한 이름의 리소스 **전체**를 보낸 데이터로 바꿔라|
|PATCH|지정한 이름의 리소스의 **일부**를 보낸 데이터로 바꿔라|
|DELETE|지정한 리소스를 서버에서 삭제해라|
|POST|지금 보내는 데이터를 서버에 등록하라(리소스 등록외에 다양한 행위를 대변할 수 있음)|

## 상태코드

서버에서 응답하는 모든 HTTP 응답 메세지는 상태 코드와 함께 반환된다.  
상태코드는 서버가 클라이언트에게 요청이 성공했는지 아니면 실패했는지 또는 추가적인 조치가 필요한지 알려준다.  
아래 사진은 흔히 볼 수 있는 404 Not Found이다.  

<img width="50%" src="https://drive.google.com/uc?id=1jqAtBibNNwt2HA9YxVmCCz8OAJKDLEuY">  

Not Found라는 메세지가 뜻하는 바와 같이 URL에 해당하는 리소스를 찾을 수 없을 때 응답하는 코드다.  
정상적으로 접속이 되는 홈페이지로 들어가서 브라우저 개발자 콘솔을 (F12) 켜보자.  
그리고 네트워크 탭을 열어보면, 200으로 된 응답들이 여러개 있을것이다.  
페이지 하나를 로드하기위한 리소스들의 요청에대한 응답들이다.

<img width="50%" src="https://drive.google.com/uc?id=1M3d-Utl2OsWBgpXFgomUvpUm6Sw8GYUk">  

위와같이 리소스에 대한 요청이 성공하면 200번대 코드를 보내준다.  
각 응답 코드의 100의자리 수 마다 통용되는 의미가 있다.  


|HTTP 상태코드|설명|
|---|---|
|100번대|요청이 수신되어 처리중 (거의 사용하지 않는다.)|
|200번대|요청 정상 처리|
|300번대|요청을 완료하려면 추가 행동이 필요|
|400번대|클라이언트 오류, 잘못된 접근이나 문법등으로 요청을 수행할 수 없음|
|500번대|서버 오류, 서버가 다운됐거나 서버가 정상 요청을 처리하지 못함|

지금은 개괄적으로만 이해를 하고 추후 좀 더 자세히 알아보자.

## HTTP 메시지

HTTP 요청과 응답 메시지의 구조를 지금은 가볍게 들여다 보자. 추후에 더 자세히 다룰 예정이다.  
HTTP 메시지는 단순 줄 단위의 문자열이다. 즉, **줄바꿈으로 내용을 구분**하고있다.  
당연히 아무렇게나 보내는것이 아닌 양식을 가지고 있다.  

<img src="https://drive.google.com/uc?id=1_ygZ8a1lTJQO1ibGr3uAcVT3_5FO6SCi">  

### 시작줄

HTTP 메시지의 첫 줄은 시작줄로, **요청**이라면 행위를 나타내는 **메서드**로 시작하고,  
**응답**이라면 요청에 대해서 어떤 결과가 일어났는지 상태코드와 함께 알려준다.  
위 그림과 같은 경우에는 POST요청을 보냈지만 서버에서는 403코드를 보내며 접근을 제한하는 응답을 보냈다.  

### 헤더 

시작줄 바로 다음줄에는 0개 이상의 헤더 필드가 이어진다.  
각 헤더 필드는 콜론(:)으로 구분되는 하나의 이름과 하나의 값으로 줄바꿈으로 구분한다.  
다른 헤더를 추가할때 한줄을 더하는 식으로 이루어진다.  

### 빈줄

헤더와 본문을 구분하기 위한 빈 줄이 있다.  
메세지 가운데 빈줄이 있으면 빈 줄 **상단에는 시작줄과 헤더**가 있고,  
**하단에는 본문**을 담고있다.

### 본문

빈 줄 다음에는 어떤 종류의 데이터든 들어갈 수 있는 메시지 본문이 **필요에 따라** 올 수 있다.  
헤더와는 달리 지켜지는 양식이 없으며, 임이의 데이터를 포함할 수 있다(이미지, 오디오, 비디오 등).  
물론 단순 텍스트도 포힘할 수 있다.  

## TCP

HTTP 만으로는 서버와 어떠한것도 주고 받을 수 없다.  
그렇다면 HTTP 메세지는 어떤 방식으로 주고받을 수 있을까?  
바로 TCP라는 프로토콜의 도움을 받아서 HTTP 메시지를 감싸서 서버로 전달하는것이다.  
TCP라는 프로토콜은 다음과 같은 사항들을 보장한다.  

- 오류 없는 데이터 전송
- 순서에 맞는 전달(언제나 보낸 순서대로 도착)
- 조각나지 않는 데이터 스트림(언제든 어떤 크기로든 보낼 수 있다.)  
  + 예를들어 500mb짜리 데이터를 보낼 때 오류가 생겨서 210mb만 저장된다던지 하는것을 방지해준다.

TCP는 인터넷 브라우저가 아닌 우리의 운영체제가 관리해서 만든다.  
우선 TCP라는 단어와 보장하는 내용에 대해서만 인지를 하고  
TCP가 무엇인지와 어떻게 메시지를 전달하는지는 추후에 더 자세히 다뤄보도록 하자.  

## 프로토콜 버전

대부분의 서버는 현재의 HTTP 버전인 1.1의 스펙을 사용중이다. 그러나 여전히 1.0스펙이 쓰이는곳이 간혹있다.  
1.0과 1.1은 기존의 구조적 결함을 교정하고, 두드러진 성능 최적화, 잘못된 기능 제거에 집중했다.  
그리고 1.1의 성능 문제를 개선하기 위해 2.0은 2015년에 공식적으로 발표가 되었고, 각종 해외사이트나,  
우리나라 다수 커뮤니티 등에서 사용중이다. [적용된 사이트](https://namu.wiki/w/HTTP/2#s-5)  

## 웹의 구성요소

기본적인 요청과 응답을 담당하는 웹 애플리케이션(웹 브라우저와 웹 서버) 말고도 인터넷과 상호작용을 하는  
애플리케이션은 많다. **각각 간략하게만** 알아보고 추후에 더 자세히 다뤄보자.  

### 프록시

<img src="https://drive.google.com/uc?id=1RFp-DvtuO_PFTF1608Bi7O9aDzkn3ec7">

프록시는 위 그림과 같이 서버와 클라이언트 사이에 위치하여, 클라이언트의 모든 HTTP요청을 받아서  
서버에 **사용자대신** 전달한다. 주로 보안을 위해서 사용되고, 요청과 응답을 필터링하거나,  
무엇인가를 다운받을 때, 바이러스를 미리 검출하고, 유해사이트를 차단하는데에도 사용된다.

### 캐시

캐시는 클라이언트와 비슷하게 서버와 클라이언트 사이에 위치한다.  
다만, **자주 찾는 내용을 저장**해놨다가 서버까지 가지않고 대신 전달 해주는 역할을 한다.  
추후 캐싱 기술에 대해서는 더 자세하게 다뤄보도록 하자. 

___
이 외에도 게이트웨이나 터널, 에이전트와 같은 애플리케이션이 있지만,  
추후 다른 포스팅으로 자세하게 다뤄볼 예정이다.